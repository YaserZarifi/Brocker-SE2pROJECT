"""
SIWE (Sign-In with Ethereum) views - EIP-4361.
Sprint 5 - Bonus Feature: Login with Ethereum wallet.

Flow:
1. Frontend requests a nonce: GET /api/v1/auth/siwe/nonce/
2. Frontend creates an EIP-4361 message and asks MetaMask to sign it
3. Frontend sends message + signature: POST /api/v1/auth/siwe/verify/
4. Backend verifies the signature, finds or creates the user,
   and returns JWT tokens (same as normal login)

The wallet_address field on the User model stores the linked Ethereum address.
"""

import logging
import secrets
import uuid

from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.cache import cache
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from siwe import SiweMessage

logger = logging.getLogger(__name__)
User = get_user_model()


@api_view(["GET"])
@permission_classes([AllowAny])
def siwe_nonce(request):
    """
    Generate a random nonce for SIWE authentication.
    The nonce is cached for 5 minutes and must be used in the SIWE message.
    """
    nonce = secrets.token_hex(16)
    # Cache the nonce for 5 minutes (keyed by nonce value)
    cache.set(f"siwe_nonce_{nonce}", True, timeout=300)
    return Response({"nonce": nonce})


@api_view(["POST"])
@permission_classes([AllowAny])
def siwe_verify(request):
    """
    Verify a SIWE message signature and return JWT tokens.

    Expected request body:
    {
        "message": "EIP-4361 message string",
        "signature": "0x..."
    }

    Returns:
    {
        "access": "<jwt-access-token>",
        "refresh": "<jwt-refresh-token>",
        "user": { ... user profile ... }
    }
    """
    message_str = request.data.get("message")
    signature = request.data.get("signature")

    if not message_str or not signature:
        return Response(
            {"detail": "Both 'message' and 'signature' are required."},
            status=status.HTTP_400_BAD_REQUEST,
        )

    try:
        # Parse and verify the SIWE message
        siwe_message = SiweMessage.from_message(message=message_str)
        siwe_message.verify(signature=signature)

        # Extract data from the verified message
        eth_address = siwe_message.address
        nonce = siwe_message.nonce

        # Verify nonce was generated by us (prevent replay attacks)
        nonce_key = f"siwe_nonce_{nonce}"
        if not cache.get(nonce_key):
            return Response(
                {"detail": "Invalid or expired nonce."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        # Delete nonce after use (one-time use)
        cache.delete(nonce_key)

        # Find or create user by wallet address
        user = _get_or_create_siwe_user(eth_address)

        # Generate JWT tokens
        refresh = RefreshToken.for_user(user)
        from .serializers import UserSerializer

        return Response(
            {
                "access": str(refresh.access_token),
                "refresh": str(refresh),
                "user": UserSerializer(user).data,
            }
        )

    except Exception as e:
        logger.warning("SIWE verification failed: %s", e)
        return Response(
            {"detail": f"SIWE verification failed: {str(e)}"},
            status=status.HTTP_400_BAD_REQUEST,
        )


def _get_or_create_siwe_user(eth_address):
    """
    Find an existing user by wallet address, or create a new one.

    Args:
        eth_address: Ethereum address (checksummed, e.g. "0x742d35...")

    Returns:
        User instance
    """
    # Normalize the Ethereum address to checksum format
    from eth_utils import to_checksum_address

    eth_address = to_checksum_address(eth_address)

    # Try to find existing user with this wallet address
    try:
        user = User.objects.get(wallet_address=eth_address)
        logger.info("SIWE login: existing user %s (%s)", user.email, eth_address)
        return user
    except User.DoesNotExist:
        pass

    # Create a new user with the wallet address
    short_addr = eth_address[:6] + "..." + eth_address[-4:]
    username = f"eth_{eth_address[-8:].lower()}"
    email = f"{username}@wallet.boursechain.ir"

    # Ensure unique username
    base_username = username
    counter = 1
    while User.objects.filter(username=username).exists():
        username = f"{base_username}_{counter}"
        counter += 1

    user = User.objects.create_user(
        username=username,
        email=email,
        password=None,  # No password for wallet-only users
        wallet_address=eth_address,
        first_name="Ethereum",
        last_name=f"User ({short_addr})",
    )
    # Wallet-only users can't log in with password
    user.set_unusable_password()
    user.save()

    logger.info("SIWE login: created new user %s (%s)", user.email, eth_address)
    return user
